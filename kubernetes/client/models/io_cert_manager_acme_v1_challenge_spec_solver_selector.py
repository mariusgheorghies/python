# coding: utf-8

"""
    Kubernetes

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: v1.20.7
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from kubernetes.client.configuration import Configuration


class IoCertManagerAcmeV1ChallengeSpecSolverSelector(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'dns_names': 'list[str]',
        'dns_zones': 'list[str]',
        'match_labels': 'dict(str, str)'
    }

    attribute_map = {
        'dns_names': 'dnsNames',
        'dns_zones': 'dnsZones',
        'match_labels': 'matchLabels'
    }

    def __init__(self, dns_names=None, dns_zones=None, match_labels=None, local_vars_configuration=None):  # noqa: E501
        """IoCertManagerAcmeV1ChallengeSpecSolverSelector - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._dns_names = None
        self._dns_zones = None
        self._match_labels = None
        self.discriminator = None

        if dns_names is not None:
            self.dns_names = dns_names
        if dns_zones is not None:
            self.dns_zones = dns_zones
        if match_labels is not None:
            self.match_labels = match_labels

    @property
    def dns_names(self):
        """Gets the dns_names of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501

        List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.  # noqa: E501

        :return: The dns_names of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501
        :rtype: list[str]
        """
        return self._dns_names

    @dns_names.setter
    def dns_names(self, dns_names):
        """Sets the dns_names of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.

        List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.  # noqa: E501

        :param dns_names: The dns_names of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501
        :type: list[str]
        """

        self._dns_names = dns_names

    @property
    def dns_zones(self):
        """Gets the dns_zones of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501

        List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.  # noqa: E501

        :return: The dns_zones of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501
        :rtype: list[str]
        """
        return self._dns_zones

    @dns_zones.setter
    def dns_zones(self, dns_zones):
        """Sets the dns_zones of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.

        List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.  # noqa: E501

        :param dns_zones: The dns_zones of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501
        :type: list[str]
        """

        self._dns_zones = dns_zones

    @property
    def match_labels(self):
        """Gets the match_labels of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501

        A label selector that is used to refine the set of certificate's that this challenge solver will apply to.  # noqa: E501

        :return: The match_labels of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501
        :rtype: dict(str, str)
        """
        return self._match_labels

    @match_labels.setter
    def match_labels(self, match_labels):
        """Sets the match_labels of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.

        A label selector that is used to refine the set of certificate's that this challenge solver will apply to.  # noqa: E501

        :param match_labels: The match_labels of this IoCertManagerAcmeV1ChallengeSpecSolverSelector.  # noqa: E501
        :type: dict(str, str)
        """

        self._match_labels = match_labels

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IoCertManagerAcmeV1ChallengeSpecSolverSelector):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, IoCertManagerAcmeV1ChallengeSpecSolverSelector):
            return True

        return self.to_dict() != other.to_dict()
