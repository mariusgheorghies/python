# coding: utf-8

"""
    Kubernetes

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: v1.25.12
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from kubernetes.client.configuration import Configuration


class OrgProjectcalicoCrdV1NetworkPolicySpec(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'egress': 'list[OrgProjectcalicoCrdV1GlobalNetworkPolicySpecEgress]',
        'ingress': 'list[OrgProjectcalicoCrdV1GlobalNetworkPolicySpecEgress]',
        'order': 'float',
        'selector': 'str',
        'service_account_selector': 'str',
        'types': 'list[str]'
    }

    attribute_map = {
        'egress': 'egress',
        'ingress': 'ingress',
        'order': 'order',
        'selector': 'selector',
        'service_account_selector': 'serviceAccountSelector',
        'types': 'types'
    }

    def __init__(self, egress=None, ingress=None, order=None, selector=None, service_account_selector=None, types=None, local_vars_configuration=None):  # noqa: E501
        """OrgProjectcalicoCrdV1NetworkPolicySpec - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._egress = None
        self._ingress = None
        self._order = None
        self._selector = None
        self._service_account_selector = None
        self._types = None
        self.discriminator = None

        if egress is not None:
            self.egress = egress
        if ingress is not None:
            self.ingress = ingress
        if order is not None:
            self.order = order
        if selector is not None:
            self.selector = selector
        if service_account_selector is not None:
            self.service_account_selector = service_account_selector
        if types is not None:
            self.types = types

    @property
    def egress(self):
        """Gets the egress of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501

        The ordered set of egress rules.  Each rule contains a set of packet match criteria and a corresponding action to apply.  # noqa: E501

        :return: The egress of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :rtype: list[OrgProjectcalicoCrdV1GlobalNetworkPolicySpecEgress]
        """
        return self._egress

    @egress.setter
    def egress(self, egress):
        """Sets the egress of this OrgProjectcalicoCrdV1NetworkPolicySpec.

        The ordered set of egress rules.  Each rule contains a set of packet match criteria and a corresponding action to apply.  # noqa: E501

        :param egress: The egress of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :type: list[OrgProjectcalicoCrdV1GlobalNetworkPolicySpecEgress]
        """

        self._egress = egress

    @property
    def ingress(self):
        """Gets the ingress of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501

        The ordered set of ingress rules.  Each rule contains a set of packet match criteria and a corresponding action to apply.  # noqa: E501

        :return: The ingress of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :rtype: list[OrgProjectcalicoCrdV1GlobalNetworkPolicySpecEgress]
        """
        return self._ingress

    @ingress.setter
    def ingress(self, ingress):
        """Sets the ingress of this OrgProjectcalicoCrdV1NetworkPolicySpec.

        The ordered set of ingress rules.  Each rule contains a set of packet match criteria and a corresponding action to apply.  # noqa: E501

        :param ingress: The ingress of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :type: list[OrgProjectcalicoCrdV1GlobalNetworkPolicySpecEgress]
        """

        self._ingress = ingress

    @property
    def order(self):
        """Gets the order of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501

        Order is an optional field that specifies the order in which the policy is applied. Policies with higher \"order\" are applied after those with lower order.  If the order is omitted, it may be considered to be \"infinite\" - i.e. the policy will be applied last.  Policies with identical order will be applied in alphanumerical order based on the Policy \"Name\".  # noqa: E501

        :return: The order of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :rtype: float
        """
        return self._order

    @order.setter
    def order(self, order):
        """Sets the order of this OrgProjectcalicoCrdV1NetworkPolicySpec.

        Order is an optional field that specifies the order in which the policy is applied. Policies with higher \"order\" are applied after those with lower order.  If the order is omitted, it may be considered to be \"infinite\" - i.e. the policy will be applied last.  Policies with identical order will be applied in alphanumerical order based on the Policy \"Name\".  # noqa: E501

        :param order: The order of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :type: float
        """

        self._order = order

    @property
    def selector(self):
        """Gets the selector of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501

        The selector is an expression used to pick pick out the endpoints that the policy should be applied to.   Selector expressions follow this syntax:    label == \"string_literal\"  ->  comparison, e.g. my_label == \"foo bar\"  label != \"string_literal\"   ->  not equal; also matches if label is not present  label in { \"a\", \"b\", \"c\", ... }  ->  true if the value of label X is one of \"a\", \"b\", \"c\"  label not in { \"a\", \"b\", \"c\", ... }  ->  true if the value of label X is not one of \"a\", \"b\", \"c\"  has(label_name)  -> True if that label is present  ! expr -> negation of expr  expr && expr  -> Short-circuit and  expr || expr  -> Short-circuit or  ( expr ) -> parens for grouping  all() or the empty selector -> matches all endpoints.   Label names are allowed to contain alphanumerics, -, _ and /. String literals are more permissive but they do not support escape characters.   Examples (with made-up labels):    type == \"webserver\" && deployment == \"prod\"  type in {\"frontend\", \"backend\"}  deployment != \"dev\"  ! has(label_name)  # noqa: E501

        :return: The selector of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :rtype: str
        """
        return self._selector

    @selector.setter
    def selector(self, selector):
        """Sets the selector of this OrgProjectcalicoCrdV1NetworkPolicySpec.

        The selector is an expression used to pick pick out the endpoints that the policy should be applied to.   Selector expressions follow this syntax:    label == \"string_literal\"  ->  comparison, e.g. my_label == \"foo bar\"  label != \"string_literal\"   ->  not equal; also matches if label is not present  label in { \"a\", \"b\", \"c\", ... }  ->  true if the value of label X is one of \"a\", \"b\", \"c\"  label not in { \"a\", \"b\", \"c\", ... }  ->  true if the value of label X is not one of \"a\", \"b\", \"c\"  has(label_name)  -> True if that label is present  ! expr -> negation of expr  expr && expr  -> Short-circuit and  expr || expr  -> Short-circuit or  ( expr ) -> parens for grouping  all() or the empty selector -> matches all endpoints.   Label names are allowed to contain alphanumerics, -, _ and /. String literals are more permissive but they do not support escape characters.   Examples (with made-up labels):    type == \"webserver\" && deployment == \"prod\"  type in {\"frontend\", \"backend\"}  deployment != \"dev\"  ! has(label_name)  # noqa: E501

        :param selector: The selector of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :type: str
        """

        self._selector = selector

    @property
    def service_account_selector(self):
        """Gets the service_account_selector of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501

        ServiceAccountSelector is an optional field for an expression used to select a pod based on service accounts.  # noqa: E501

        :return: The service_account_selector of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :rtype: str
        """
        return self._service_account_selector

    @service_account_selector.setter
    def service_account_selector(self, service_account_selector):
        """Sets the service_account_selector of this OrgProjectcalicoCrdV1NetworkPolicySpec.

        ServiceAccountSelector is an optional field for an expression used to select a pod based on service accounts.  # noqa: E501

        :param service_account_selector: The service_account_selector of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :type: str
        """

        self._service_account_selector = service_account_selector

    @property
    def types(self):
        """Gets the types of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501

        Types indicates whether this policy applies to ingress, or to egress, or to both.  When not explicitly specified (and so the value on creation is empty or nil), Calico defaults Types according to what Ingress and Egress are present in the policy.  The default is:   - [ PolicyTypeIngress ], if there are no Egress rules (including the case where there are   also no Ingress rules)   - [ PolicyTypeEgress ], if there are Egress rules but no Ingress rules   - [ PolicyTypeIngress, PolicyTypeEgress ], if there are both Ingress and Egress rules.   When the policy is read back again, Types will always be one of these values, never empty or nil.  # noqa: E501

        :return: The types of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :rtype: list[str]
        """
        return self._types

    @types.setter
    def types(self, types):
        """Sets the types of this OrgProjectcalicoCrdV1NetworkPolicySpec.

        Types indicates whether this policy applies to ingress, or to egress, or to both.  When not explicitly specified (and so the value on creation is empty or nil), Calico defaults Types according to what Ingress and Egress are present in the policy.  The default is:   - [ PolicyTypeIngress ], if there are no Egress rules (including the case where there are   also no Ingress rules)   - [ PolicyTypeEgress ], if there are Egress rules but no Ingress rules   - [ PolicyTypeIngress, PolicyTypeEgress ], if there are both Ingress and Egress rules.   When the policy is read back again, Types will always be one of these values, never empty or nil.  # noqa: E501

        :param types: The types of this OrgProjectcalicoCrdV1NetworkPolicySpec.  # noqa: E501
        :type: list[str]
        """

        self._types = types

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, OrgProjectcalicoCrdV1NetworkPolicySpec):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, OrgProjectcalicoCrdV1NetworkPolicySpec):
            return True

        return self.to_dict() != other.to_dict()
