# coding: utf-8

"""
    Kubernetes

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: v1.25.12
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from kubernetes.client.configuration import Configuration


class OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'namespace_selector': 'str',
        'nets': 'list[str]',
        'not_nets': 'list[str]',
        'not_ports': 'list[object]',
        'not_selector': 'str',
        'ports': 'list[object]',
        'selector': 'str',
        'service_accounts': 'OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestinationServiceAccounts'
    }

    attribute_map = {
        'namespace_selector': 'namespaceSelector',
        'nets': 'nets',
        'not_nets': 'notNets',
        'not_ports': 'notPorts',
        'not_selector': 'notSelector',
        'ports': 'ports',
        'selector': 'selector',
        'service_accounts': 'serviceAccounts'
    }

    def __init__(self, namespace_selector=None, nets=None, not_nets=None, not_ports=None, not_selector=None, ports=None, selector=None, service_accounts=None, local_vars_configuration=None):  # noqa: E501
        """OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._namespace_selector = None
        self._nets = None
        self._not_nets = None
        self._not_ports = None
        self._not_selector = None
        self._ports = None
        self._selector = None
        self._service_accounts = None
        self.discriminator = None

        if namespace_selector is not None:
            self.namespace_selector = namespace_selector
        if nets is not None:
            self.nets = nets
        if not_nets is not None:
            self.not_nets = not_nets
        if not_ports is not None:
            self.not_ports = not_ports
        if not_selector is not None:
            self.not_selector = not_selector
        if ports is not None:
            self.ports = ports
        if selector is not None:
            self.selector = selector
        if service_accounts is not None:
            self.service_accounts = service_accounts

    @property
    def namespace_selector(self):
        """Gets the namespace_selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501

        NamespaceSelector is an optional field that contains a selector expression. Only traffic that originates from (or terminates at) endpoints within the selected namespaces will be matched. When both NamespaceSelector and Selector are defined on the same rule, then only workload endpoints that are matched by both selectors will be selected by the rule.   For NetworkPolicy, an empty NamespaceSelector implies that the Selector is limited to selecting only workload endpoints in the same namespace as the NetworkPolicy.   For NetworkPolicy, `global()` NamespaceSelector implies that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.   For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies to workload endpoints across all namespaces.  # noqa: E501

        :return: The namespace_selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :rtype: str
        """
        return self._namespace_selector

    @namespace_selector.setter
    def namespace_selector(self, namespace_selector):
        """Sets the namespace_selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.

        NamespaceSelector is an optional field that contains a selector expression. Only traffic that originates from (or terminates at) endpoints within the selected namespaces will be matched. When both NamespaceSelector and Selector are defined on the same rule, then only workload endpoints that are matched by both selectors will be selected by the rule.   For NetworkPolicy, an empty NamespaceSelector implies that the Selector is limited to selecting only workload endpoints in the same namespace as the NetworkPolicy.   For NetworkPolicy, `global()` NamespaceSelector implies that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.   For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies to workload endpoints across all namespaces.  # noqa: E501

        :param namespace_selector: The namespace_selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :type: str
        """

        self._namespace_selector = namespace_selector

    @property
    def nets(self):
        """Gets the nets of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501

        Nets is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) IP addresses in any of the given subnets.  # noqa: E501

        :return: The nets of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :rtype: list[str]
        """
        return self._nets

    @nets.setter
    def nets(self, nets):
        """Sets the nets of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.

        Nets is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) IP addresses in any of the given subnets.  # noqa: E501

        :param nets: The nets of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :type: list[str]
        """

        self._nets = nets

    @property
    def not_nets(self):
        """Gets the not_nets of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501

        NotNets is the negated version of the Nets field.  # noqa: E501

        :return: The not_nets of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :rtype: list[str]
        """
        return self._not_nets

    @not_nets.setter
    def not_nets(self, not_nets):
        """Sets the not_nets of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.

        NotNets is the negated version of the Nets field.  # noqa: E501

        :param not_nets: The not_nets of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :type: list[str]
        """

        self._not_nets = not_nets

    @property
    def not_ports(self):
        """Gets the not_ports of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501

        NotPorts is the negated version of the Ports field. Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \"TCP\" or \"UDP\".  # noqa: E501

        :return: The not_ports of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :rtype: list[object]
        """
        return self._not_ports

    @not_ports.setter
    def not_ports(self, not_ports):
        """Sets the not_ports of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.

        NotPorts is the negated version of the Ports field. Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \"TCP\" or \"UDP\".  # noqa: E501

        :param not_ports: The not_ports of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :type: list[object]
        """

        self._not_ports = not_ports

    @property
    def not_selector(self):
        """Gets the not_selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501

        NotSelector is the negated version of the Selector field.  See Selector field for subtleties with negated selectors.  # noqa: E501

        :return: The not_selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :rtype: str
        """
        return self._not_selector

    @not_selector.setter
    def not_selector(self, not_selector):
        """Sets the not_selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.

        NotSelector is the negated version of the Selector field.  See Selector field for subtleties with negated selectors.  # noqa: E501

        :param not_selector: The not_selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :type: str
        """

        self._not_selector = not_selector

    @property
    def ports(self):
        """Gets the ports of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501

        Ports is an optional field that restricts the rule to only apply to traffic that has a source (destination) port that matches one of these ranges/values. This value is a list of integers or strings that represent ranges of ports.   Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \"TCP\" or \"UDP\".  # noqa: E501

        :return: The ports of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :rtype: list[object]
        """
        return self._ports

    @ports.setter
    def ports(self, ports):
        """Sets the ports of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.

        Ports is an optional field that restricts the rule to only apply to traffic that has a source (destination) port that matches one of these ranges/values. This value is a list of integers or strings that represent ranges of ports.   Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \"TCP\" or \"UDP\".  # noqa: E501

        :param ports: The ports of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :type: list[object]
        """

        self._ports = ports

    @property
    def selector(self):
        """Gets the selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501

        Selector is an optional field that contains a selector expression (see Policy for sample syntax).  Only traffic that originates from (terminates at) endpoints matching the selector will be matched.   Note that: in addition to the negated version of the Selector (see NotSelector below), the selector expression syntax itself supports negation.  The two types of negation are subtly different. One negates the set of matched endpoints, the other negates the whole match:    Selector = \"!has(my_label)\" matches packets that are from other Calico-controlled  endpoints that do not have the label “my_label”.    NotSelector = \"has(my_label)\" matches packets that are not from Calico-controlled  endpoints that do have the label “my_label”.   The effect is that the latter will accept packets from non-Calico sources whereas the former is limited to packets from Calico-controlled endpoints.  # noqa: E501

        :return: The selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :rtype: str
        """
        return self._selector

    @selector.setter
    def selector(self, selector):
        """Sets the selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.

        Selector is an optional field that contains a selector expression (see Policy for sample syntax).  Only traffic that originates from (terminates at) endpoints matching the selector will be matched.   Note that: in addition to the negated version of the Selector (see NotSelector below), the selector expression syntax itself supports negation.  The two types of negation are subtly different. One negates the set of matched endpoints, the other negates the whole match:    Selector = \"!has(my_label)\" matches packets that are from other Calico-controlled  endpoints that do not have the label “my_label”.    NotSelector = \"has(my_label)\" matches packets that are not from Calico-controlled  endpoints that do have the label “my_label”.   The effect is that the latter will accept packets from non-Calico sources whereas the former is limited to packets from Calico-controlled endpoints.  # noqa: E501

        :param selector: The selector of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :type: str
        """

        self._selector = selector

    @property
    def service_accounts(self):
        """Gets the service_accounts of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501


        :return: The service_accounts of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :rtype: OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestinationServiceAccounts
        """
        return self._service_accounts

    @service_accounts.setter
    def service_accounts(self, service_accounts):
        """Sets the service_accounts of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.


        :param service_accounts: The service_accounts of this OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination.  # noqa: E501
        :type: OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestinationServiceAccounts
        """

        self._service_accounts = service_accounts

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, OrgProjectcalicoCrdV1GlobalNetworkPolicySpecDestination):
            return True

        return self.to_dict() != other.to_dict()
